"""
CFO Agent - Chief Financial Officer for budget and cost management.

Capabilities:
- Budget allocation and enforcement
- Cost-aware model selection
- Spend tracking and reporting
- Cost optimization recommendations
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

from adapters.base import LLMMessage
from adapters.router import get_router
from agents.framework.base_agent import BaseAgent

if TYPE_CHECKING:
    from titan.costs.budget import BudgetTracker
    from titan.costs.router import CostAwareRouter

logger = logging.getLogger("titan.agents.cfo")


@dataclass
class BudgetRecommendation:
    """Recommendation from CFO agent."""

    action: str
    allocated_usd: float
    model_tier: str
    model_id: str
    reasoning: str
    constraints: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)


@dataclass
class SpendReport:
    """Spend report generated by CFO."""

    session_id: str
    total_spend_usd: float
    budget_remaining_usd: float
    utilization_percent: float
    by_model: dict[str, float]
    by_agent: dict[str, float]
    recommendations: list[str]


class CFOAgent(BaseAgent):
    """
    Chief Financial Officer agent for budget and cost management.

    Responsibilities:
    - Allocate budgets for tasks and agents
    - Select cost-appropriate models based on task complexity
    - Track and report spending
    - Enforce budget limits
    - Provide cost optimization recommendations
    """

    def __init__(
        self,
        budget_tracker: BudgetTracker | None = None,
        cost_router: CostAwareRouter | None = None,
        session_budget_usd: float = 10.0,
        agent_budget_usd: float = 2.0,
        **kwargs: Any,
    ) -> None:
        kwargs.setdefault("name", "cfo")
        kwargs.setdefault("capabilities", ["budget", "cost_optimization", "reporting"])
        super().__init__(**kwargs)

        self._budget_tracker = budget_tracker
        self._cost_router = cost_router
        self._session_budget_usd = session_budget_usd
        self._agent_budget_usd = agent_budget_usd
        self._router = get_router()

        # Track decisions for reporting
        self._allocations: list[BudgetRecommendation] = []
        self._model_selections: list[dict[str, Any]] = []

    def set_budget_tracker(self, tracker: BudgetTracker) -> None:
        """Set the budget tracker."""
        self._budget_tracker = tracker

    def set_cost_router(self, router: CostAwareRouter) -> None:
        """Set the cost-aware router."""
        self._cost_router = router

    async def initialize(self) -> None:
        """Initialize the CFO agent."""
        logger.info(f"CFO Agent '{self.name}' initializing")

        # Initialize router if available
        await self._router.initialize()

        # Create session budget if tracker available
        if self._budget_tracker and self._session_id:
            await self._budget_tracker.create_session_budget(
                self._session_id,
                limit_usd=self._session_budget_usd,
            )
            logger.info(f"Created session budget: ${self._session_budget_usd}")

    async def work(self) -> dict[str, Any]:
        """
        Main work loop - CFO doesn't have a specific task,
        but can be queried for budget decisions.
        """
        logger.info("CFO Agent ready to serve budget requests")

        # Generate initial spend report
        report = await self.generate_spend_report()

        return {
            "status": "ready",
            "session_budget": self._session_budget_usd,
            "initial_report": report,
        }

    async def shutdown(self) -> None:
        """Cleanup CFO agent."""
        logger.info("CFO Agent shutting down")

        # Generate final report
        report = await self.generate_spend_report()

        # Store in memory
        if self._hive_mind:
            await self.remember(
                content=f"CFO Final Report:\n"
                f"Total Spend: ${report.total_spend_usd:.4f}\n"
                f"Utilization: {report.utilization_percent:.1f}%\n"
                f"Recommendations: {', '.join(report.recommendations)}",
                importance=0.8,
                tags=["cfo", "report", "budget"],
            )

    async def allocate_budget(
        self,
        task: str,
        agent_id: str | None = None,
        requested_usd: float | None = None,
    ) -> BudgetRecommendation:
        """
        Allocate budget for a task.

        Args:
            task: Task description
            agent_id: Optional agent ID for agent-level budget
            requested_usd: Requested budget amount

        Returns:
            BudgetRecommendation with allocation details
        """
        self.increment_turn()

        warnings = []
        constraints = []

        # Get current budget status
        remaining = self._session_budget_usd
        if self._budget_tracker and self._session_id:
            remaining = await self._budget_tracker.get_remaining(self._session_id)

        # Determine appropriate model tier based on task
        model_tier = "standard"
        model_id = "gpt-4o-mini"
        estimated_cost = 0.01

        if self._cost_router:
            decision = await self._cost_router.select_model(
                task,
                session_id=self._session_id,
                agent_id=agent_id,
            )
            model_tier = decision.tier.value
            model_id = decision.model_id
            estimated_cost = decision.estimated_cost
            constraints.extend(decision.constraints_applied)

        # Determine allocation
        if requested_usd:
            if requested_usd > remaining:
                warnings.append(
                    f"Requested ${requested_usd:.4f} exceeds remaining ${remaining:.4f}"
                )
                allocated = min(requested_usd, remaining)
            else:
                allocated = requested_usd
        else:
            # Auto-allocate based on task complexity
            allocated = min(self._agent_budget_usd, remaining, estimated_cost * 10)

        # Check if we can afford it
        if allocated < estimated_cost:
            warnings.append(
                f"Allocated ${allocated:.4f} may be insufficient "
                f"for estimated cost ${estimated_cost:.4f}"
            )
            # Downgrade model tier if needed
            model_tier = "economy"
            model_id = "gpt-4o-mini"

        reasoning = f"Task complexity suggests {model_tier} tier. "
        reasoning += f"Allocated ${allocated:.4f} from remaining ${remaining:.4f}. "
        reasoning += f"Recommended model: {model_id}"

        recommendation = BudgetRecommendation(
            action="allocate",
            allocated_usd=allocated,
            model_tier=model_tier,
            model_id=model_id,
            reasoning=reasoning,
            constraints=constraints,
            warnings=warnings,
        )

        self._allocations.append(recommendation)

        # Create agent budget if tracker available
        if self._budget_tracker and agent_id and self._session_id:
            await self._budget_tracker.create_agent_budget(
                agent_id=agent_id,
                session_id=self._session_id,
                limit_usd=allocated,
            )

        # Log decision
        await self.log_decision(
            decision=f"Allocated ${allocated:.4f} for task",
            category="budget",
            rationale=reasoning,
            tags=["cfo", "allocation", model_tier],
        )

        logger.info(f"Budget allocated: ${allocated:.4f} for {agent_id or 'task'}")
        return recommendation

    async def select_model(
        self,
        task: str,
        max_cost_usd: float | None = None,
        agent_id: str | None = None,
    ) -> BudgetRecommendation:
        """
        Select appropriate model for a task based on complexity and budget.

        Args:
            task: Task description
            max_cost_usd: Maximum cost constraint
            agent_id: Agent making the request

        Returns:
            BudgetRecommendation with model selection
        """
        self.increment_turn()

        # Get remaining budget
        remaining = self._session_budget_usd
        if self._budget_tracker and self._session_id:
            remaining = await self._budget_tracker.get_remaining(self._session_id)
            if agent_id:
                agent_budget = await self._budget_tracker.get_agent_budget(agent_id)
                if agent_budget:
                    remaining = min(remaining, agent_budget.remaining_usd)

        # Apply max cost constraint
        if max_cost_usd:
            remaining = min(remaining, max_cost_usd)

        # Use cost-aware router if available
        if self._cost_router:
            decision = await self._cost_router.select_model(
                task,
                session_id=self._session_id,
                agent_id=agent_id,
            )

            recommendation = BudgetRecommendation(
                action="model_selection",
                allocated_usd=decision.estimated_cost,
                model_tier=decision.tier.value,
                model_id=decision.model_id,
                reasoning=decision.reasoning,
                constraints=decision.constraints_applied,
            )
        else:
            # Simple fallback logic
            task_lower = task.lower()

            if any(kw in task_lower for kw in ["simple", "format", "trivial"]):
                model_tier = "economy"
                model_id = "gpt-3.5-turbo"
                estimated_cost = 0.001
            elif any(kw in task_lower for kw in ["complex", "analyze", "implement"]):
                model_tier = "premium"
                model_id = "claude-3-5-sonnet-20241022"
                estimated_cost = 0.02
            else:
                model_tier = "standard"
                model_id = "gpt-4o-mini"
                estimated_cost = 0.005

            # Check if we can afford premium
            if estimated_cost > remaining:
                model_tier = "economy"
                model_id = "gpt-4o-mini"
                estimated_cost = 0.001

            recommendation = BudgetRecommendation(
                action="model_selection",
                allocated_usd=estimated_cost,
                model_tier=model_tier,
                model_id=model_id,
                reasoning=(
                    f"Selected {model_tier} tier based on task analysis. Budget: ${remaining:.4f}"
                ),
            )

        self._model_selections.append(
            {
                "task": task[:100],
                "model": recommendation.model_id,
                "tier": recommendation.model_tier,
                "cost": recommendation.allocated_usd,
            }
        )

        logger.info(f"Model selected: {recommendation.model_id} ({recommendation.model_tier})")
        return recommendation

    async def record_spend(
        self,
        amount_usd: float,
        model: str,
        provider: str,
        input_tokens: int = 0,
        output_tokens: int = 0,
        agent_id: str | None = None,
    ) -> bool:
        """
        Record spending for tracking.

        Args:
            amount_usd: Amount spent
            model: Model used
            provider: Provider used
            input_tokens: Input tokens used
            output_tokens: Output tokens used
            agent_id: Agent that incurred the spend

        Returns:
            True if recorded successfully
        """
        if not self._budget_tracker or not self._session_id:
            return False

        try:
            await self._budget_tracker.record_spend(
                session_id=self._session_id,
                amount_usd=amount_usd,
                agent_id=agent_id,
                model=model,
                provider=provider,
                input_tokens=input_tokens,
                output_tokens=output_tokens,
            )
            return True
        except Exception as e:
            logger.error(f"Failed to record spend: {e}")
            return False

    async def check_budget(
        self,
        estimated_cost: float,
        agent_id: str | None = None,
    ) -> tuple[bool, str]:
        """
        Check if a request can be afforded.

        Args:
            estimated_cost: Estimated cost of the request
            agent_id: Agent making the request

        Returns:
            Tuple of (can_afford, reason)
        """
        if not self._budget_tracker or not self._session_id:
            return True, "No budget tracking enabled"

        return await self._budget_tracker.can_afford(
            session_id=self._session_id,
            estimated_cost=estimated_cost,
            agent_id=agent_id,
        )

    async def generate_spend_report(self) -> SpendReport:
        """
        Generate a comprehensive spend report.

        Returns:
            SpendReport with spending details and recommendations
        """
        if not self._budget_tracker or not self._session_id:
            return SpendReport(
                session_id=self._session_id or "unknown",
                total_spend_usd=0.0,
                budget_remaining_usd=self._session_budget_usd,
                utilization_percent=0.0,
                by_model={},
                by_agent={},
                recommendations=["Enable budget tracking for detailed reports"],
            )

        summary = await self._budget_tracker.get_spend_summary(
            session_id=self._session_id,
        )

        budget = await self._budget_tracker.get_budget(self._session_id)
        remaining = budget.remaining_usd if budget else self._session_budget_usd
        allocated = budget.allocated_usd if budget else self._session_budget_usd
        utilization = ((allocated - remaining) / allocated * 100) if allocated > 0 else 0

        # Generate recommendations
        recommendations = []

        if utilization > 80:
            recommendations.append(
                "Budget utilization high. Consider increasing limits or optimizing model selection."
            )

        if summary.get("by_model", {}):
            most_expensive = max(summary["by_model"].items(), key=lambda x: x[1])
            if most_expensive[1] > summary["total_spend_usd"] * 0.5:
                recommendations.append(
                    f"High spend on {most_expensive[0]}. "
                    "Consider using economy models for simpler tasks."
                )

        if not recommendations:
            recommendations.append("Budget usage is healthy.")

        return SpendReport(
            session_id=self._session_id,
            total_spend_usd=summary.get("total_spend_usd", 0.0),
            budget_remaining_usd=remaining,
            utilization_percent=utilization,
            by_model=summary.get("by_model", {}),
            by_agent={},  # Would need agent-level tracking
            recommendations=recommendations,
        )

    async def get_optimization_advice(self) -> str:
        """
        Get AI-powered cost optimization advice.

        Returns:
            Optimization recommendations
        """
        self.increment_turn()

        report = await self.generate_spend_report()
        spending_lines = chr(10).join(
            f"- {model}: ${spend:.4f}" for model, spend in report.by_model.items()
        )
        recent_lines = chr(10).join(
            f"- {sel['task'][:50]}... -> {sel['model']}" for sel in self._model_selections[-5:]
        )

        messages = [
            LLMMessage(
                role="user",
                content=(
                    f"As a CFO AI, analyze this spending report and provide "
                    f"optimization advice:\n\n"
                    f"Total Spend: ${report.total_spend_usd:.4f}\n"
                    f"Budget Remaining: ${report.budget_remaining_usd:.4f}\n"
                    f"Utilization: {report.utilization_percent:.1f}%\n\n"
                    "Spending by Model:\n"
                    f"{spending_lines}\n\n"
                    "Recent Model Selections:\n"
                    f"{recent_lines}\n\n"
                    "Provide 3-5 specific, actionable recommendations "
                    "for optimizing costs while maintaining quality."
                ),
            )
        ]

        response = await self._router.complete(
            messages,
            system="You are a CFO AI assistant. Provide practical cost optimization advice.",
            max_tokens=300,
        )

        return response.content
